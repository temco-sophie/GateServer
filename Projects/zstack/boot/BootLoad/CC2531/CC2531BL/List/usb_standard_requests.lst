###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         18/Jan/2013  10:11:29 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1a #
#                          \Components\hal\target\CC2530USB\usb\library\usb_s #
#                          tandard_requests.c                                 #
#    Command line       =  "D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1 #
#                          a\Components\hal\target\CC2530USB\usb\library\usb_ #
#                          standard_requests.c" -D HAL_SB_BOOT_CODE -lC       #
#                          "D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1 #
#                          a\Projects\zstack\boot\BootLoad\CC2531\CC2531BL\Li #
#                          st\" -lA "D:\Texas Instruments\GIT_CORD\ZStack-CC2 #
#                          530-2.5.1a\Projects\zstack\boot\BootLoad\CC2531\CC #
#                          2531BL\List\" -o "D:\Texas                         #
#                          Instruments\GIT_CORD\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\boot\BootLoad\CC2531\CC2531BL\Obj\" -e     #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=near               #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 16 -I     #
#                          "D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1 #
#                          a\Projects\zstack\boot\BootLoad\CC2531\..\Source\" #
#                           -I "D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2 #
#                          .5.1a\Projects\zstack\boot\BootLoad\CC2531\source\ #
#                          " -I "D:\Texas Instruments\GIT_CORD\ZStack-CC2530- #
#                          2.5.1a\Projects\zstack\boot\BootLoad\CC2531\..\..\ #
#                          ..\..\..\COMPONENTS\HAL\INCLUDE\" -I "D:\Texas     #
#                          Instruments\GIT_CORD\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\boot\BootLoad\CC2531\..\..\..\..\..\COMPON #
#                          ENTS\HAL\TARGET\_COMMON\CC2530\" -I "D:\Texas      #
#                          Instruments\GIT_CORD\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\boot\BootLoad\CC2531\..\..\..\..\..\COMPON #
#                          ENTS\HAL\TARGET\CC2530USB\" -I "D:\Texas           #
#                          Instruments\GIT_CORD\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\boot\BootLoad\CC2531\..\..\..\..\..\COMPON #
#                          ENTS\HAL\TARGET\CC2530USB\usb\library\" -I         #
#                          "D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1 #
#                          a\Projects\zstack\boot\BootLoad\CC2531\..\..\..\.. #
#                          \..\COMPONENTS\HAL\TARGET\CC2530USB\usb\library\cc #
#                          2531\" -I "D:\Texas Instruments\GIT_CORD\ZStack-CC #
#                          2530-2.5.1a\Projects\zstack\boot\BootLoad\CC2531\. #
#                          .\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530USB\usb\ #
#                          class_cdc\" -Ohz --require_prototypes              #
#    List file          =  D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1a #
#                          \Projects\zstack\boot\BootLoad\CC2531\CC2531BL\Lis #
#                          t\usb_standard_requests.lst                        #
#    Object file        =  D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1a #
#                          \Projects\zstack\boot\BootLoad\CC2531\CC2531BL\Obj #
#                          \usb_standard_requests.r51                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\GIT_CORD\ZStack-CC2530-2.5.1a\Components\hal\target\CC2530USB\usb\library\usb_standard_requests.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_standard_request.c
      4          
      5              Description:  Handle USB standard requests.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_standard_requests
     10          /// @{
     11          #include "usb_firmware_library_headers.h"
     12          #include "hal_types.h"
     13          #include "hal_board.h"
     14          
     15          
     16          
     17          /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
     18           *
     19           * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
     20           * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
     21           * changed with the SET_FEATURE and CLEAR_FEATURE requests.
     22           *
     23           * <b>Parameters</b>:
     24           * - VALUE: Always 0
     25           * - INDEX: Depends upon the recipient:
     26           *     - DEVICE: Always 0
     27           *     - INTERFACE: Interface number
     28           *     - ENDPOINT: Endpoint address
     29           * - LENGTH: Always 2
     30           *
     31           * <b>Data (IN)</b>:
     32           * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
     33           * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
     34           * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
     35           * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
     36           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     37          void usbsrGetStatus(void)
   \                     usbsrGetStatus:
     38          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
     39             uint8 endpoint;
     40             static uint16 __xdata status;
     41          
     42             // Common sanity check
     43             if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
   \   000005   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_23:
   \   000008   7011         JNZ     ??usbsrGetStatus_0
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   700A         JNZ     ??usbsrGetStatus_0
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6402         XRL     A,#0x2
   \   000015   7002         JNZ     ??usbsrGetStatus_1
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??usbsrGetStatus_1:
   \   000019   6008         JZ      ??usbsrGetStatus_2
     44                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetStatus_0:
   \   00001B   90....       MOV     DPTR,#usbfwData + 7
   \   00001E   7404         MOV     A,#0x4
   \   000020   02....       LJMP    ??CrossCallReturnLabel_13
     45          
     46             // Return status for device, interface, or endpoint
     47             } else {
     48                switch (usbSetupHeader.requestType) {
   \                     ??usbsrGetStatus_2:
   \   000023   90....       MOV     DPTR,#usbSetupHeader
   \   000026   E0           MOVX    A,@DPTR
   \   000027   2480         ADD     A,#-0x80
   \   000029   6008         JZ      ??usbsrGetStatus_3
   \   00002B   14           DEC     A
   \   00002C   602A         JZ      ??usbsrGetStatus_4
   \   00002E   14           DEC     A
   \   00002F   6037         JZ      ??usbsrGetStatus_5
   \   000031   80E8         SJMP    ??usbsrGetStatus_0
     49          
     50                   // Device status:
     51                   //     Bit 0: Self powered
     52                   //     Bit 1: Remote wake-up allowed
     53                case RT_IN_DEVICE:
     54          
     55                   // Sanity check
     56                   if (LO_UINT16(usbSetupHeader.index)) {
   \                     ??usbsrGetStatus_3:
   \   000033   E8           MOV     A,R0
   \   000034   70E5         JNZ     ??usbsrGetStatus_0
     57                      usbfwData.ep0Status = EP_STALL;
     58          
     59                   // Get the bit values from the USBFW_DATA struct
     60                   } else {
     61          
     62                      // Self powered?
     63                      status = usbfwData.selfPowered ? 0x0001 : 0x0000;
   \   000036   90....       MOV     DPTR,#usbfwData + 19
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6004         JZ      ??usbsrGetStatus_6
   \   00003C   7801         MOV     R0,#0x1
   \   00003E   8002         SJMP    ??usbsrGetStatus_7
   \                     ??usbsrGetStatus_6:
   \   000040   7800         MOV     R0,#0x0
   \                     ??usbsrGetStatus_7:
   \   000042   90....       MOV     DPTR,#??status
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
     64          
     65                      // Remote wakeup?
     66                      if (usbfwData.remoteWakeup) status |= 0x0002;
   \   00004A   90....       MOV     DPTR,#usbfwData + 18
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   6068         JZ      ??usbsrGetStatus_8
   \   000050   90....       MOV     DPTR,#??status
   \   000053   E0           MOVX    A,@DPTR
   \   000054   4402         ORL     A,#0x2
   \   000056   805C         SJMP    ??usbsrGetStatus_9
     67                   }
     68                   break;
     69          
     70                   // Interface status:
     71                   //     All bits are reserved
     72                case RT_IN_INTERFACE:
     73          
     74                   // Sanity check
     75                   if (usbfwData.usbState != DEV_CONFIGURED) {
   \                     ??usbsrGetStatus_4:
   \   000058   90....       MOV     DPTR,#usbfwData
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6404         XRL     A,#0x4
   \   00005E   70BB         JNZ     ??usbsrGetStatus_0
     76                      usbfwData.ep0Status = EP_STALL;
     77                   } else {
     78                      status = 0x0000;
   \   000060   90....       MOV     DPTR,#??status
   \   000063   E4           CLR     A
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   804F         SJMP    ??usbsrGetStatus_10
     79                   }
     80                   break;
     81          
     82                   // Endpoint status:
     83                   //     Bit 0: Endpoint halted
     84                case RT_IN_ENDPOINT:
     85                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
   \                     ??usbsrGetStatus_5:
   \   000068   E8           MOV     A,R0
   \   000069   547F         ANL     A,#0x7f
   \   00006B   F5..         MOV     ?V0 + 0,A
     86          
     87                   // Sanity check
     88                   if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
   \   00006D   90....       MOV     DPTR,#usbfwData
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6404         XRL     A,#0x4
   \   000073   70A6         JNZ     ??usbsrGetStatus_0
   \   000075   E5..         MOV     A,?V0 + 0
   \   000077   C3           CLR     C
   \   000078   9406         SUBB    A,#0x6
   \   00007A   509F         JNC     ??usbsrGetStatus_0
     89                      usbfwData.ep0Status = EP_STALL;
     90          
     91                   // Translate endpoint address to status index and return the status
     92                   } else {
     93          
     94                      // IN
     95                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
   \   00007C   74..         MOV     A,#usbfwData & 0xff
   \   00007E   25..         ADD     A,?V0 + 0
   \   000080   F582         MOV     DPL,A
   \   000082   74..         MOV     A,#(usbfwData >> 8) & 0xff
   \   000084   3400         ADDC    A,#0x0
   \   000086   F583         MOV     DPH,A
   \   000088   E8           MOV     A,R0
   \   000089   5480         ANL     A,#0x80
   \   00008B   6010         JZ      ??usbsrGetStatus_11
     96                         status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   6403         XRL     A,#0x3
   \   000097   7015         JNZ     ??usbsrGetStatus_12
   \                     ??usbsrGetStatus_13:
   \   000099   7801         MOV     R0,#0x1
   \   00009B   8013         SJMP    ??usbsrGetStatus_14
     97          
     98                      // OUT
     99                      } else {
    100                         status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
   \                     ??usbsrGetStatus_11:
   \   00009D   E582         MOV     A,DPL
   \   00009F   240C         ADD     A,#0xc
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   E583         MOV     A,DPH
   \   0000A5   3400         ADDC    A,#0x0
   \   0000A7   F583         MOV     DPH,A
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   6403         XRL     A,#0x3
   \   0000AC   60EB         JZ      ??usbsrGetStatus_13
   \                     ??usbsrGetStatus_12:
   \   0000AE   7800         MOV     R0,#0x0
   \                     ??usbsrGetStatus_14:
   \   0000B0   90....       MOV     DPTR,#??status
   \   0000B3   E8           MOV     A,R0
   \                     ??usbsrGetStatus_9:
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E4           CLR     A
   \                     ??usbsrGetStatus_10:
   \   0000B7   F0           MOVX    @DPTR,A
    101                      }
    102                   }
    103                   break;
    104          
    105                default:
    106                   usbfwData.ep0Status = EP_STALL;
    107                   break;
    108                }
    109          
    110                if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetStatus_8:
   \   0000B8   90....       MOV     DPTR,#usbfwData + 7
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   6404         XRL     A,#0x4
   \   0000BE   6014         JZ      ??usbsrGetStatus_15
    111                   // Send it
    112                   usbSetupData.pBuffer = (uint8 __generic *)&status;
   \   0000C0   90....       MOV     DPTR,#usbSetupData
   \   0000C3   74..         MOV     A,#??status & 0xff
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   74..         MOV     A,#(??status >> 8) & 0xff
   \   0000C9   F0           MOVX    @DPTR,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E4           CLR     A
   \   0000CC   F0           MOVX    @DPTR,A
    113                   usbSetupData.bytesLeft = 2;
   \   0000CD   A3           INC     DPTR
   \   0000CE   7402         MOV     A,#0x2
   \   0000D0   12....       LCALL   ?Subroutine9
    114                   usbfwData.ep0Status = EP_TX;
    115                }
    116             }
   \                     ??CrossCallReturnLabel_13:
   \   0000D3   F0           MOVX    @DPTR,A
    117          } // usbsrGetStatus
   \                     ??usbsrGetStatus_15:
   \   0000D4                REQUIRE ?Subroutine0
   \   0000D4                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000003                REQUIRE ??Subroutine10_0
   \   000003                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   90....       MOV     DPTR,#usbfwData + 7
   \   000007   04           INC     A
   \   000008   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??status:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    118          
    119          
    120          
    121          
    122          /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
    123           *
    124           * This function either sets or clears the specified feature on the specified recipient.
    125           *
    126           * \param[in]       set
    127           *     When TRUE, the feature is set. When FALSE, the feature is cleared.
    128           *
    129           * \return
    130           *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
    131           *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
    132           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    133          static uint8 ChangeFeature(uint8 set)
   \                     ChangeFeature:
    134          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    135             uint8 endpoint;
    136          
    137             // Sanity check
    138             if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
   \   000007   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00000A   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_15:
   \   00000D   7010         JNZ     ??ChangeFeature_0
   \   00000F   90....       MOV     DPTR,#usbfwData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6404         XRL     A,#0x4
   \   000015   6010         JZ      ??ChangeFeature_1
   \   000017   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00001A   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_16:
   \   00001D   6008         JZ      ??ChangeFeature_1
    139                usbfwData.ep0Status = EP_STALL;
   \                     ??ChangeFeature_0:
   \   00001F   90....       MOV     DPTR,#usbfwData + 7
   \   000022   7404         MOV     A,#0x4
   \   000024   02....       LJMP    ??ChangeFeature_2
    140          
    141                // Handle based on recipient
    142             } else {
    143                switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
   \                     ??ChangeFeature_1:
   \   000027   90....       MOV     DPTR,#usbSetupHeader
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   541F         ANL     A,#0x1f
   \   00002D   6008         JZ      ??ChangeFeature_3
   \   00002F   14           DEC     A
   \   000030   600D         JZ      ??ChangeFeature_4
   \   000032   14           DEC     A
   \   000033   6024         JZ      ??ChangeFeature_5
   \   000035   80E8         SJMP    ??ChangeFeature_0
    144          
    145                // Device
    146                case RT_RECIP_DEV:
    147          
    148                   // Sanity check
    149                   if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
   \                     ??ChangeFeature_3:
   \   000037   90....       MOV     DPTR,#usbSetupHeader + 2
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6401         XRL     A,#0x1
   \   00003D   6005         JZ      ??ChangeFeature_6
    150                      return FALSE;
   \                     ??ChangeFeature_4:
   \   00003F   7900         MOV     R1,#0x0
   \   000041   02....       LJMP    ??ChangeFeature_7
    151                   } else {
    152                      usbfwData.remoteWakeup = set;
   \                     ??ChangeFeature_6:
   \   000044   EE           MOV     A,R6
   \   000045   90....       MOV     DPTR,#usbfwData + 18
   \   000048   F0           MOVX    @DPTR,A
    153                      usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
   \   000049   6004         JZ      ??ChangeFeature_8
   \   00004B   7905         MOV     R1,#0x5
   \   00004D   8002         SJMP    ??ChangeFeature_9
   \                     ??ChangeFeature_8:
   \   00004F   7906         MOV     R1,#0x6
   \                     ??ChangeFeature_9:
   \   000051                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000051   7A00         MOV     R2,#0x0
   \   000053   12....       LCALL   usbsrHookProcessEvent
    154                   }
    155                   break;
   \   000056   02....       LJMP    ??ChangeFeature_10
    156          
    157                // Endpoint
    158                case RT_RECIP_IF:
    159                   return FALSE;
    160          
    161                // Endpoint
    162                case RT_RECIP_EP:
    163                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
   \                     ??ChangeFeature_5:
   \   000059   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   547F         ANL     A,#0x7f
   \   00005F   FA           MOV     R2,A
    164          
    165                   // Sanity check
    166                   if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
   \   000060   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000063   E0           MOVX    A,@DPTR
   \   000064   70D9         JNZ     ??ChangeFeature_4
    167                      return FALSE;
    168                   } else if (endpoint > 5) {
   \   000066   EA           MOV     A,R2
   \   000067   C3           CLR     C
   \   000068   9406         SUBB    A,#0x6
   \   00006A   50B3         JNC     ??ChangeFeature_0
    169                      usbfwData.ep0Status = EP_STALL;
    170                   } else {
    171                      USBFW_SELECT_ENDPOINT(endpoint);
   \   00006C   EA           MOV     A,R2
   \   00006D   90620E       MOV     DPTR,#0x620e
   \   000070   F0           MOVX    @DPTR,A
    172          
    173                      // IN
    174                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
   \   000071   8A..         MOV     ?V0 + 0,R2
   \   000073   74..         MOV     A,#usbfwData & 0xff
   \   000075   25..         ADD     A,?V0 + 0
   \   000077   F8           MOV     R0,A
   \   000078   74..         MOV     A,#(usbfwData >> 8) & 0xff
   \   00007A   3400         ADDC    A,#0x0
   \   00007C   F9           MOV     R1,A
   \   00007D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000080   E0           MOVX    A,@DPTR
   \   000081   5480         ANL     A,#0x80
   \   000083   602C         JZ      ??ChangeFeature_11
    175                         USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
   \   000085   EE           MOV     A,R6
   \   000086   6004         JZ      ??ChangeFeature_12
   \   000088   7410         MOV     A,#0x10
   \   00008A   8002         SJMP    ??ChangeFeature_13
   \                     ??ChangeFeature_12:
   \   00008C   7440         MOV     A,#0x40
   \                     ??ChangeFeature_13:
   \   00008E   906211       MOV     DPTR,#0x6211
   \   000091   F0           MOVX    @DPTR,A
    176                         usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   000092   EE           MOV     A,R6
   \   000093   6004         JZ      ??ChangeFeature_14
   \   000095   7403         MOV     A,#0x3
   \   000097   8001         SJMP    ??ChangeFeature_15
   \                     ??ChangeFeature_14:
   \   000099   E4           CLR     A
   \                     ??ChangeFeature_15:
   \   00009A   8882         MOV     DPL,R0
   \   00009C   8983         MOV     DPH,R1
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   F0           MOVX    @DPTR,A
    177                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
   \   0000A6   EE           MOV     A,R6
   \   0000A7   6004         JZ      ??ChangeFeature_16
   \   0000A9   7908         MOV     R1,#0x8
   \   0000AB   8031         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_16:
   \   0000AD   7907         MOV     R1,#0x7
   \   0000AF                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000AF   802D         SJMP    ??ChangeFeature_17
    178          
    179                      // OUT
    180                      } else {
    181                         USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
   \                     ??ChangeFeature_11:
   \   0000B1   EE           MOV     A,R6
   \   0000B2   6004         JZ      ??ChangeFeature_18
   \   0000B4   7420         MOV     A,#0x20
   \   0000B6   8002         SJMP    ??ChangeFeature_19
   \                     ??ChangeFeature_18:
   \   0000B8   7480         MOV     A,#-0x80
   \                     ??ChangeFeature_19:
   \   0000BA   906214       MOV     DPTR,#0x6214
   \   0000BD   F0           MOVX    @DPTR,A
    182                         usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   0000BE   EE           MOV     A,R6
   \   0000BF   6004         JZ      ??ChangeFeature_20
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   8001         SJMP    ??ChangeFeature_21
   \                     ??ChangeFeature_20:
   \   0000C5   E4           CLR     A
   \                     ??ChangeFeature_21:
   \   0000C6   C0E0         PUSH    A
   \   0000C8   E8           MOV     A,R0
   \   0000C9   240C         ADD     A,#0xc
   \   0000CB   F582         MOV     DPL,A
   \   0000CD   E9           MOV     A,R1
   \   0000CE   3400         ADDC    A,#0x0
   \   0000D0   F583         MOV     DPH,A
   \   0000D2   D0E0         POP     A
   \   0000D4   F0           MOVX    @DPTR,A
    183                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
   \   0000D5   EE           MOV     A,R6
   \   0000D6   6004         JZ      ??ChangeFeature_22
   \   0000D8   790A         MOV     R1,#0xa
   \   0000DA   8002         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_22:
   \   0000DC   7909         MOV     R1,#0x9
   \                     ??ChangeFeature_17:
   \   0000DE                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000DE   12....       LCALL   usbsrHookProcessEvent
    184                      }
    185                      USBFW_SELECT_ENDPOINT(0);
   \   0000E1   90620E       MOV     DPTR,#0x620e
   \   0000E4   E4           CLR     A
   \                     ??ChangeFeature_2:
   \   0000E5   F0           MOVX    @DPTR,A
    186                   }
    187                   break;
    188          
    189                default:
    190                   usbfwData.ep0Status = EP_STALL;
    191                   break;
    192                }
    193             }
    194             return TRUE;
   \                     ??ChangeFeature_10:
   \   0000E6   7901         MOV     R1,#0x1
   \                     ??ChangeFeature_7:
   \   0000E8   02....       LJMP    ?Subroutine0
    195          } // ChangeFeature
    196          
    197          
    198          
    199          
    200          /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
    201           *
    202           * The feature selector value must be appropriate to the recipient.
    203           *
    204           * <b>Parameters</b>:
    205           * - VALUE: Feature selector:
    206           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    207           *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
    208           * - INDEX: Depends upon the recipient:
    209           *     - DEVICE: Always 0
    210           *     - INTERFACE: Interface number
    211           *     - ENDPOINT: Endpoint address
    212           * - LENGTH: Always 0
    213           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    214          void usbsrClearFeature()
   \                     usbsrClearFeature:
    215          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    216             if (!ChangeFeature(FALSE)) {
   \   000000                ; Setup parameters for call to function ChangeFeature
   \   000000   7900         MOV     R1,#0x0
   \   000002   12....       LCALL   ChangeFeature
   \   000005   E9           MOV     A,R1
   \   000006   7003         JNZ     ??usbsrClearFeature_0
    217                usbsrHookClearFeature();
   \   000008                ; Setup parameters for call to function usbsrHookClearFeature
   \   000008   12....       LCALL   usbsrHookClearFeature
    218             }
    219          } // usbsrClearFeature
   \                     ??usbsrClearFeature_0:
   \   00000B   22           RET
    220          
    221          
    222          
    223          
    224          /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
    225           *
    226           * The feature selector value must be appropriate to the recipient.
    227           *
    228           * <b>Parameters</b>:
    229           * - VALUE: Feature selector:
    230           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    231           *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
    232           * - INDEX: Depends upon the recipient:
    233           *     - DEVICE: Always 0
    234           *     - INTERFACE: Interface number
    235           *     - ENDPOINT: Endpoint address
    236           * - LENGTH: Always 0
    237           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    238          void usbsrSetFeature(void)
   \                     usbsrSetFeature:
    239          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    240             if (!ChangeFeature(TRUE)) {
   \   000000                ; Setup parameters for call to function ChangeFeature
   \   000000   7901         MOV     R1,#0x1
   \   000002   12....       LCALL   ChangeFeature
   \   000005   E9           MOV     A,R1
   \   000006   7003         JNZ     ??usbsrSetFeature_0
    241                usbsrHookSetFeature();
   \   000008                ; Setup parameters for call to function usbsrHookSetFeature
   \   000008   12....       LCALL   usbsrHookSetFeature
    242             }
    243          } // usbsrSetFeature
   \                     ??usbsrSetFeature_0:
   \   00000B   22           RET
    244          
    245          
    246          
    247          
    248          /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
    249           * accesses)
    250           *
    251           * If the value is between 1 and 127 and the device is in the default state, it will enter the address
    252           * state. If it already is in the address state, it starts to use the newly-specified address.
    253           *
    254           * If the value is 0 and the device is in the address state, it will enter the default state. If it
    255           * already is in the default state, nothing happens.
    256           *
    257           * <b>Parameters</b>:
    258           * - VALUE: The device address (0-127)
    259           * - INDEX: Always 0
    260           * - LENGTH: Always 0
    261           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    262          void usbsrSetAddress(void)
   \                     usbsrSetAddress:
    263          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    264          
    265             // Sanity check
    266             if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
   \   000004   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000007   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_17:
   \   00000A   7015         JNZ     ??usbsrSetAddress_0
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_18:
   \   000010   700F         JNZ     ??usbsrSetAddress_0
   \   000012   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000015   12....       LCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_0:
   \   000018   5480         ANL     A,#0x80
   \   00001A   FA           MOV     R2,A
   \   00001B   E9           MOV     A,R1
   \   00001C   FB           MOV     R3,A
   \   00001D   EA           MOV     A,R2
   \   00001E   4B           ORL     A,R3
   \   00001F   6007         JZ      ??usbsrSetAddress_1
    267                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetAddress_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   801A         SJMP    ??usbsrSetAddress_2
    268          
    269             // Update the device address
    270             } else {
    271                USBADDR = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetAddress_1:
   \   000028   E8           MOV     A,R0
   \   000029   906200       MOV     DPTR,#0x6200
   \   00002C   F0           MOVX    @DPTR,A
    272                if (LO_UINT16(usbSetupHeader.value) != 0) {
   \   00002D   90....       MOV     DPTR,#usbfwData
   \   000030   6009         JZ      ??usbsrSetAddress_3
    273                   if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6402         XRL     A,#0x2
   \   000035   700C         JNZ     ??usbsrSetAddress_4
   \   000037   7403         MOV     A,#0x3
   \   000039   8007         SJMP    ??usbsrSetAddress_2
    274                } else {
    275                   if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
   \                     ??usbsrSetAddress_3:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6403         XRL     A,#0x3
   \   00003E   7003         JNZ     ??usbsrSetAddress_4
   \   000040   7402         MOV     A,#0x2
   \                     ??usbsrSetAddress_2:
   \   000042   F0           MOVX    @DPTR,A
    276                }
    277             }
    278          
    279          } // usbsrSetAddress
   \                     ??usbsrSetAddress_4:
   \   000043                REQUIRE ?Subroutine1
   \   000043                ; // Fall through to label ?Subroutine1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET
    280          
    281          
    282          
    283          
    284          /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
    285           *
    286           * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
    287           * descriptors. Note that configuration descriptors also include interface, endpoint and other
    288           * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
    289           * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
    290           *
    291           * Other descriptor types that are not returned with the configuration descriptor, must be defined in
    292           * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
    293           * gives a pointer to the descriptor along with it's length.
    294           *
    295           * <b>Parameters</b>:
    296           * - VALUE.MSB: Descriptor type
    297           * - VALUE.LSB: Descriptor index
    298           * - INDEX: 0, or language ID for string descriptors (currently not supported)
    299           * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
    300           *           whichever is the smallest)
    301           *
    302           * <b>Data (IN)</b>:
    303           * The descriptor(s)
    304           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    305          void usbsrGetDescriptor(void)
   \                     usbsrGetDescriptor:
    306          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
    307             uint8 n;
    308          
    309             // Which descriptor?
    310             switch (HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   14           DEC     A
   \   00000D   6008         JZ      ??usbsrGetDescriptor_0
   \   00000F   14           DEC     A
   \   000010   6019         JZ      ??usbsrGetDescriptor_1
   \   000012   14           DEC     A
   \   000013   6047         JZ      ??usbsrGetDescriptor_2
   \   000015   805C         SJMP    ??usbsrGetDescriptor_3
    311          
    312             // Device descriptor
    313             case DESC_TYPE_DEVICE:
    314                usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
   \                     ??usbsrGetDescriptor_0:
   \   000017                ; Setup parameters for call to function usbdpGetDeviceDesc
   \   000017   12....       LCALL   usbdpGetDeviceDesc
   \   00001A   12....       LCALL   ?Subroutine5
    315                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_5:
   \   00001D   A3           INC     DPTR
   \   00001E   7B80         MOV     R3,#-0x80
   \                     ??usbsrGetDescriptor_4:
   \   000020   12....       LCALL   ?C_GPTR_LOAD
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E4           CLR     A
   \                     ??usbsrGetDescriptor_5:
   \   000027   F0           MOVX    @DPTR,A
    316                break;
   \   000028   02....       LJMP    ??usbsrGetDescriptor_6
    317          
    318             // Configuration descriptor
    319             case DESC_TYPE_CONFIG:
    320                usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_1:
   \   00002B                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   12....       LCALL   usbdpGetConfigurationDesc
   \   000030   12....       LCALL   ?Subroutine5
    321                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
    322                                         usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
   \                     ??CrossCallReturnLabel_6:
   \   000033   7B80         MOV     R3,#-0x80
   \   000035   E9           MOV     A,R1
   \   000036   2402         ADD     A,#0x2
   \   000038   09           INC     R1
   \   000039   09           INC     R1
   \   00003A   EA           MOV     A,R2
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   FA           MOV     R2,A
   \   00003E   12....       LCALL   ?C_GPTR_LOAD
   \   000041   FC           MOV     R4,A
   \   000042   19           DEC     R1
   \   000043   19           DEC     R1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FA           MOV     R2,A
   \   000046   A3           INC     DPTR
   \   000047   E9           MOV     A,R1
   \   000048   2403         ADD     A,#0x3
   \   00004A   09           INC     R1
   \   00004B   09           INC     R1
   \   00004C   09           INC     R1
   \   00004D   EA           MOV     A,R2
   \   00004E   3400         ADDC    A,#0x0
   \   000050   FA           MOV     R2,A
   \   000051   12....       LCALL   ?C_GPTR_LOAD
   \   000054   F9           MOV     R1,A
   \   000055   EC           MOV     A,R4
   \   000056   A3           INC     DPTR
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   80CB         SJMP    ??usbsrGetDescriptor_5
    323                break;
    324          
    325             // String descriptor
    326             case DESC_TYPE_STRING:
    327                // TODO: Implement language ID
    328                usbSetupData.pBuffer = (uint8 *)usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_2:
   \   00005C                ; Setup parameters for call to function usbdpGetStringDesc
   \   00005C   EA           MOV     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   12....       LCALL   usbdpGetStringDesc
   \   000061   90....       MOV     DPTR,#usbSetupData
   \   000064   EA           MOV     A,R2
   \   000065   F0           MOVX    @DPTR,A
   \   000066   A3           INC     DPTR
   \   000067   EB           MOV     A,R3
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   E4           CLR     A
   \   00006B   12....       LCALL   ?Subroutine8
    329                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_11:
   \   00006E   A3           INC     DPTR
   \   00006F   7B00         MOV     R3,#0x0
   \   000071   80AD         SJMP    ??usbsrGetDescriptor_4
    330                break;
    331          
    332             // Other descriptor type
    333             default:
    334                // Perform a table search (on index and value)
    335                usbSetupData.pBuffer = NULL;
   \                     ??usbsrGetDescriptor_3:
   \   000073   90....       MOV     DPTR,#usbSetupData
   \   000076   E4           CLR     A
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   F0           MOVX    @DPTR,A
    336                for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
   \   00007C   F5..         MOV     ?V0 + 3,A
   \   00007E   90....       MOV     DPTR,#usbDescriptorMarker + 4
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FA           MOV     R2,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FB           MOV     R3,A
   \   000086   02....       LJMP    ??usbsrGetDescriptor_7
    337                   if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
    338                       && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
    339                       && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
    340                       && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
   \                     ??usbsrGetDescriptor_8:
   \   000089   75..00       MOV     ?V0 + 1,#0x0
   \   00008C   7403         MOV     A,#0x3
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?S_SHL
   \   000093   EA           MOV     A,R2
   \   000094   25..         ADD     A,?V0 + 0
   \   000096   F8           MOV     R0,A
   \   000097   EB           MOV     A,R3
   \   000098   35..         ADDC    A,?V0 + 1
   \   00009A   F9           MOV     R1,A
   \   00009B   90....       MOV     DPTR,#usbSetupHeader + 2
   \   00009E   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_3:
   \   0000A1   E4           CLR     A
   \   0000A2   93           MOVC    A,@A+DPTR
   \   0000A3   C0E0         PUSH    A
   \   0000A5   EF           MOV     A,R7
   \   0000A6   FC           MOV     R4,A
   \   0000A7   D0E0         POP     A
   \   0000A9   6C           XRL     A,R4
   \   0000AA   705D         JNZ     ??usbsrGetDescriptor_9
   \   0000AC   A3           INC     DPTR
   \   0000AD   E4           CLR     A
   \   0000AE   93           MOVC    A,@A+DPTR
   \   0000AF   6E           XRL     A,R6
   \   0000B0   7057         JNZ     ??usbsrGetDescriptor_9
   \   0000B2   90....       MOV     DPTR,#usbSetupHeader + 4
   \   0000B5   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_4:
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   E4           CLR     A
   \   0000BB   93           MOVC    A,@A+DPTR
   \   0000BC   C0E0         PUSH    A
   \   0000BE   EF           MOV     A,R7
   \   0000BF   FC           MOV     R4,A
   \   0000C0   D0E0         POP     A
   \   0000C2   6C           XRL     A,R4
   \   0000C3   7044         JNZ     ??usbsrGetDescriptor_9
   \   0000C5   8882         MOV     DPL,R0
   \   0000C7   8983         MOV     DPH,R1
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   E4           CLR     A
   \   0000CD   93           MOVC    A,@A+DPTR
   \   0000CE   6E           XRL     A,R6
   \   0000CF   7038         JNZ     ??usbsrGetDescriptor_9
    341                   {
    342                      usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
   \   0000D1   8882         MOV     DPL,R0
   \   0000D3   8983         MOV     DPH,R1
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   E4           CLR     A
   \   0000DA   93           MOVC    A,@A+DPTR
   \   0000DB   F5..         MOV     ?V0 + 0,A
   \   0000DD   7401         MOV     A,#0x1
   \   0000DF   93           MOVC    A,@A+DPTR
   \   0000E0   F5..         MOV     ?V0 + 1,A
   \   0000E2   90....       MOV     DPTR,#usbSetupData
   \   0000E5   E5..         MOV     A,?V0 + 0
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   E5..         MOV     A,?V0 + 1
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   7480         MOV     A,#-0x80
   \   0000EF   F0           MOVX    @DPTR,A
    343                      usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
   \   0000F0   8882         MOV     DPL,R0
   \   0000F2   8983         MOV     DPH,R1
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   A3           INC     DPTR
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   A3           INC     DPTR
   \   0000FA   E4           CLR     A
   \   0000FB   93           MOVC    A,@A+DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   7401         MOV     A,#0x1
   \   0000FF   93           MOVC    A,@A+DPTR
   \   000100   F9           MOV     R1,A
   \   000101   90....       MOV     DPTR,#usbSetupData + 3
   \   000104   E8           MOV     A,R0
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E9           MOV     A,R1
   \   000108   F0           MOVX    @DPTR,A
    344                   }
    345                }
   \                     ??usbsrGetDescriptor_9:
   \   000109   05..         INC     ?V0 + 3
   \                     ??usbsrGetDescriptor_7:
   \   00010B   85....       MOV     ?V0 + 0,?V0 + 3
   \   00010E   90....       MOV     DPTR,#usbDescriptorMarker + 6
   \   000111   12....       LCALL   ?Subroutine3
    346             }
   \                     ??CrossCallReturnLabel_1:
   \   000114   C3           CLR     C
   \   000115   9A           SUBB    A,R2
   \   000116   F5..         MOV     ?V0 + 4,A
   \   000118   E9           MOV     A,R1
   \   000119   9B           SUBB    A,R3
   \   00011A   F5..         MOV     ?V0 + 5,A
   \   00011C   7403         MOV     A,#0x3
   \   00011E   78..         MOV     R0,#?V0 + 4
   \   000120   12....       LCALL   ?US_SHR
   \   000123   C3           CLR     C
   \   000124   E5..         MOV     A,?V0 + 0
   \   000126   95..         SUBB    A,?V0 + 4
   \   000128   E4           CLR     A
   \   000129   95..         SUBB    A,?V0 + 5
   \   00012B   5003         JNC     $+5
   \   00012D   02....       LJMP    ??usbsrGetDescriptor_8
    347          
    348             // Stall EP0 if no descriptor was found
    349             if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetDescriptor_6:
   \   000130   90....       MOV     DPTR,#usbSetupData
   \   000133   E0           MOVX    A,@DPTR
   \   000134   FC           MOV     R4,A
   \   000135   A3           INC     DPTR
   \   000136   E0           MOVX    A,@DPTR
   \   000137   FD           MOV     R5,A
   \   000138   A3           INC     DPTR
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   FE           MOV     R6,A
   \   00013B   EC           MOV     A,R4
   \   00013C   4D           ORL     A,R5
   \   00013D   4E           ORL     A,R6
   \   00013E   90....       MOV     DPTR,#usbfwData + 7
   \   000141   7004         JNZ     ??usbsrGetDescriptor_10
   \   000143   7404         MOV     A,#0x4
   \   000145   8029         SJMP    ??usbsrGetDescriptor_11
    350          
    351             if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetDescriptor_10:
   \   000147   E0           MOVX    A,@DPTR
   \   000148   6404         XRL     A,#0x4
   \   00014A   6025         JZ      ??usbsrGetDescriptor_12
    352          
    353                // Limit the returned descriptor size (the PC wants to know about sizes before
    354                // polling the complete descriptors)
    355                if (usbSetupData.bytesLeft > usbSetupHeader.length) {
   \   00014C   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   FA           MOV     R2,A
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   FB           MOV     R3,A
   \   000154   90....       MOV     DPTR,#usbSetupData + 3
   \   000157   E0           MOVX    A,@DPTR
   \   000158   F8           MOV     R0,A
   \   000159   A3           INC     DPTR
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F9           MOV     R1,A
   \   00015C   C3           CLR     C
   \   00015D   EA           MOV     A,R2
   \   00015E   98           SUBB    A,R0
   \   00015F   EB           MOV     A,R3
   \   000160   99           SUBB    A,R1
   \   000161   5008         JNC     ??usbsrGetDescriptor_13
    356                   usbSetupData.bytesLeft = usbSetupHeader.length;
   \   000163   90....       MOV     DPTR,#usbSetupData + 3
   \   000166   EA           MOV     A,R2
   \   000167   F0           MOVX    @DPTR,A
   \   000168   A3           INC     DPTR
   \   000169   EB           MOV     A,R3
   \   00016A   F0           MOVX    @DPTR,A
    357                }
    358          
    359                usbfwData.ep0Status = EP_TX;
   \                     ??usbsrGetDescriptor_13:
   \   00016B   90....       MOV     DPTR,#usbfwData + 7
   \   00016E   7401         MOV     A,#0x1
   \                     ??usbsrGetDescriptor_11:
   \   000170   F0           MOVX    @DPTR,A
    360             }
    361          
    362          } // usbsrGetDescriptor
   \                     ??usbsrGetDescriptor_12:
   \   000171   7F06         MOV     R7,#0x6
   \   000173   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV     DPTR,#usbSetupData
   \   000003   EA           MOV     A,R2
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   EB           MOV     A,R3
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   7480         MOV     A,#-0x80
   \   00000B   12....       LCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_12:
   \   00000E   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#usbSetupData
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET
    363          
    364          
    365          
    366          /** \brief Internally used function that configures all endpoints for the specified interface
    367           *
    368           * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
    369           * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
    370           * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
    371           * interface descriptor to define endpoint double-buffering.
    372           *
    373           * \param[in]       *pInterface
    374           *     A pointer to the interface descriptor
    375           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    376          static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
   \                     ConfigureEndpoints:
    377          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
    378             uint8 n;
    379             uint16 maxpRegValue;
    380             uint8 csRegValue;
    381             uint8 endpoint;
    382             USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
    383             DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
    384          
    385             // Locate the double buffer settings
    386             if (pInterface->bNumEndpoints) {
   \   000005   EA           MOV     A,R2
   \   000006   2404         ADD     A,#0x4
   \   000008   F8           MOV     R0,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F9           MOV     R1,A
   \   00000D   88..         MOV     ?V0 + 0,R0
   \   00000F   89..         MOV     ?V0 + 1,R1
   \   000011   8882         MOV     DPL,R0
   \   000013   F583         MOV     DPH,A
   \   000015   E4           CLR     A
   \   000016   93           MOVC    A,@A+DPTR
   \   000017   6025         JZ      ??ConfigureEndpoints_0
    387                 pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
   \   000019   90....       MOV     DPTR,#usbDescriptorMarker + 8
   \   00001C   12....       LCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_2:
   \   00001F   FE           MOV     R6,A
   \   000020   E9           MOV     A,R1
   \   000021   8007         SJMP    ??ConfigureEndpoints_1
    388                 while (pUsbDblbufLutInfo->pInterface != pInterface) {
    389                    pUsbDblbufLutInfo++;
   \                     ??ConfigureEndpoints_2:
   \   000023   EE           MOV     A,R6
   \   000024   2404         ADD     A,#0x4
   \   000026   FE           MOV     R6,A
   \   000027   EF           MOV     A,R7
   \   000028   3400         ADDC    A,#0x0
   \                     ??ConfigureEndpoints_1:
   \   00002A   FF           MOV     R7,A
    390                 }
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   E4           CLR     A
   \   000030   93           MOVC    A,@A+DPTR
   \   000031   F8           MOV     R0,A
   \   000032   7401         MOV     A,#0x1
   \   000034   93           MOVC    A,@A+DPTR
   \   000035   F9           MOV     R1,A
   \   000036   EA           MOV     A,R2
   \   000037   68           XRL     A,R0
   \   000038   7002         JNZ     ??ConfigureEndpoints_3
   \   00003A   EB           MOV     A,R3
   \   00003B   69           XRL     A,R1
   \                     ??ConfigureEndpoints_3:
   \   00003C   70E5         JNZ     ??ConfigureEndpoints_2
    391             }
    392          
    393             // For each endpoint in this interface
    394             for (n = 0; n < pInterface->bNumEndpoints; n++) {
   \                     ??ConfigureEndpoints_0:
   \   00003E   75..00       MOV     ?V0 + 4,#0x0
   \   000041   8040         SJMP    ??ConfigureEndpoints_4
    395                if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
    396          
    397                   // Get the endpoint index
    398                   endpoint = pEndpoint->bEndpointAddress & 0x0F;
    399                   USBFW_SELECT_ENDPOINT(endpoint);
    400          
    401                   csRegValue = 0x00;
    402                   maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
    403          
    404                   // For IN endpoints...
    405                   if (pEndpoint->bEndpointAddress & 0x80) {
    406          
    407                      // Clear data toggle, and flush twice (due to double buffering)
    408                      USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
    409                      USBCSIL = USBCSIL_FLUSH_PACKET;
    410          
    411                      // USBCSIH
    412                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
    413                      if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
    414                      USBCSIH = csRegValue;
    415          
    416                      // Max transfer size
    417                      USBMAXI = maxpRegValue;
    418          
    419                      // Endpoint status
    420                      usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
    421          
    422                   // For OUT endpoints...
    423                   } else {
    424          
    425                      // Clear data toggle, and flush twice (due to double buffering)
    426                      USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
   \                     ??ConfigureEndpoints_5:
   \   000043   906214       MOV     DPTR,#0x6214
   \   000046   7490         MOV     A,#-0x70
   \   000048   F0           MOVX    @DPTR,A
    427                      USBCSOL = USBCSOL_FLUSH_PACKET;
   \   000049   7410         MOV     A,#0x10
   \   00004B   12....       LCALL   ?Subroutine7
    428          
    429                      // USBCSOH
    430                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
   \                     ??CrossCallReturnLabel_9:
   \   00004E   7003         JNZ     ??ConfigureEndpoints_6
   \   000050   75..40       MOV     ?V0 + 5,#0x40
    431                      if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
   \                     ??ConfigureEndpoints_6:
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E4           CLR     A
   \   00005B   93           MOVC    A,@A+DPTR
   \   00005C   55..         ANL     A,?V0 + 8
   \   00005E   6006         JZ      ??ConfigureEndpoints_7
   \   000060   E5..         MOV     A,?V0 + 5
   \   000062   D2E0         SETB    0xE0 /* A   */.0
   \   000064   F5..         MOV     ?V0 + 5,A
    432                      USBCSOH = csRegValue;
   \                     ??ConfigureEndpoints_7:
   \   000066   E5..         MOV     A,?V0 + 5
   \   000068   906215       MOV     DPTR,#0x6215
   \   00006B   F0           MOVX    @DPTR,A
    433          
    434                      // Max transfer size
    435                      USBMAXO = maxpRegValue;
   \   00006C   EA           MOV     A,R2
   \   00006D   906213       MOV     DPTR,#0x6213
   \   000070   F0           MOVX    @DPTR,A
    436          
    437                      // Endpoint status
    438                      usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
   \   000071   EC           MOV     A,R4
   \   000072   240C         ADD     A,#0xc
   \   000074   F582         MOV     DPL,A
   \   000076   ED           MOV     A,R5
   \   000077   3400         ADDC    A,#0x0
   \   000079   F583         MOV     DPH,A
   \                     ??ConfigureEndpoints_8:
   \   00007B   E4           CLR     A
   \   00007C   F0           MOVX    @DPTR,A
    439                   }
    440                   USBFW_SELECT_ENDPOINT(0);
   \   00007D   90620E       MOV     DPTR,#0x620e
   \   000080   F0           MOVX    @DPTR,A
   \                     ??ConfigureEndpoints_9:
   \   000081   05..         INC     ?V0 + 4
   \                     ??ConfigureEndpoints_4:
   \   000083   85..82       MOV     DPL,?V0 + 0
   \   000086   85..83       MOV     DPH,?V0 + 1
   \   000089   E4           CLR     A
   \   00008A   93           MOVC    A,@A+DPTR
   \   00008B   F8           MOV     R0,A
   \   00008C   E5..         MOV     A,?V0 + 4
   \   00008E   C3           CLR     C
   \   00008F   98           SUBB    A,R0
   \   000090   4003         JC      $+5
   \   000092   02....       LJMP    ??ConfigureEndpoints_10
   \   000095                ; Setup parameters for call to function usbdpFindNext
   \   000095   7A00         MOV     R2,#0x0
   \   000097   7905         MOV     R1,#0x5
   \   000099   12....       LCALL   usbdpFindNext
   \   00009C   8A..         MOV     ?V0 + 6,R2
   \   00009E   8B..         MOV     ?V0 + 7,R3
   \   0000A0   EA           MOV     A,R2
   \   0000A1   45..         ORL     A,?V0 + 7
   \   0000A3   60DC         JZ      ??ConfigureEndpoints_9
   \   0000A5   EA           MOV     A,R2
   \   0000A6   2402         ADD     A,#0x2
   \   0000A8   F8           MOV     R0,A
   \   0000A9   EB           MOV     A,R3
   \   0000AA   3400         ADDC    A,#0x0
   \   0000AC   F9           MOV     R1,A
   \   0000AD   88..         MOV     ?V0 + 2,R0
   \   0000AF   89..         MOV     ?V0 + 3,R1
   \   0000B1   8882         MOV     DPL,R0
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   E4           CLR     A
   \   0000B6   93           MOVC    A,@A+DPTR
   \   0000B7   540F         ANL     A,#0xf
   \   0000B9   F5..         MOV     ?V0 + 10,A
   \   0000BB   90620E       MOV     DPTR,#0x620e
   \   0000BE   F0           MOVX    @DPTR,A
   \   0000BF   75..00       MOV     ?V0 + 5,#0x0
   \   0000C2   8A82         MOV     DPL,R2
   \   0000C4   8B83         MOV     DPH,R3
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   E4           CLR     A
   \   0000CB   93           MOVC    A,@A+DPTR
   \   0000CC   2407         ADD     A,#0x7
   \   0000CE   F5..         MOV     ?V0 + 8,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E4           CLR     A
   \   0000D2   93           MOVC    A,@A+DPTR
   \   0000D3   3400         ADDC    A,#0x0
   \   0000D5   F5..         MOV     ?V0 + 9,A
   \   0000D7   7403         MOV     A,#0x3
   \   0000D9   78..         MOV     R0,#?V0 + 8
   \   0000DB   12....       LCALL   ?US_SHR
   \   0000DE   AA..         MOV     R2,?V0 + 8
   \   0000E0   85....       MOV     ?V0 + 8,?V0 + 10
   \   0000E3   74..         MOV     A,#usbfwData & 0xff
   \   0000E5   25..         ADD     A,?V0 + 8
   \   0000E7   F8           MOV     R0,A
   \   0000E8   74..         MOV     A,#(usbfwData >> 8) & 0xff
   \   0000EA   3400         ADDC    A,#0x0
   \   0000EC   F9           MOV     R1,A
   \   0000ED   E8           MOV     A,R0
   \   0000EE   FC           MOV     R4,A
   \   0000EF   E9           MOV     A,R1
   \   0000F0   FD           MOV     R5,A
   \   0000F1   75..01       MOV     ?V0 + 8,#0x1
   \   0000F4   75..00       MOV     ?V0 + 9,#0x0
   \   0000F7   E5..         MOV     A,?V0 + 10
   \   0000F9   78..         MOV     R0,#?V0 + 8
   \   0000FB   12....       LCALL   ?S_SHL
   \   0000FE   E5..         MOV     A,?V0 + 6
   \   000100   2403         ADD     A,#0x3
   \   000102   F8           MOV     R0,A
   \   000103   EB           MOV     A,R3
   \   000104   3400         ADDC    A,#0x0
   \   000106   F9           MOV     R1,A
   \   000107   85..82       MOV     DPL,?V0 + 2
   \   00010A   85..83       MOV     DPH,?V0 + 3
   \   00010D   E4           CLR     A
   \   00010E   93           MOVC    A,@A+DPTR
   \   00010F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000111   4003         JC      $+5
   \   000113   02....       LJMP    ??ConfigureEndpoints_5
   \   000116   906211       MOV     DPTR,#0x6211
   \   000119   7448         MOV     A,#0x48
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   7408         MOV     A,#0x8
   \   00011E   12....       LCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_10:
   \   000121   7003         JNZ     ??ConfigureEndpoints_11
   \   000123   75..40       MOV     ?V0 + 5,#0x40
   \                     ??ConfigureEndpoints_11:
   \   000126   8E82         MOV     DPL,R6
   \   000128   8F83         MOV     DPH,R7
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   E4           CLR     A
   \   00012D   93           MOVC    A,@A+DPTR
   \   00012E   55..         ANL     A,?V0 + 8
   \   000130   6006         JZ      ??ConfigureEndpoints_12
   \   000132   E5..         MOV     A,?V0 + 5
   \   000134   D2E0         SETB    0xE0 /* A   */.0
   \   000136   F5..         MOV     ?V0 + 5,A
   \                     ??ConfigureEndpoints_12:
   \   000138   E5..         MOV     A,?V0 + 5
   \   00013A   906212       MOV     DPTR,#0x6212
   \   00013D   F0           MOVX    @DPTR,A
   \   00013E   EA           MOV     A,R2
   \   00013F   906210       MOV     DPTR,#0x6210
   \   000142   F0           MOVX    @DPTR,A
   \   000143   8C82         MOV     DPL,R4
   \   000145   8D83         MOV     DPH,R5
   \   000147   A3           INC     DPTR
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   A3           INC     DPTR
   \   00014D   A3           INC     DPTR
   \   00014E   02....       LJMP    ??ConfigureEndpoints_8
    441                }
    442             }
    443          } // ConfigureEndpoints
   \                     ??ConfigureEndpoints_10:
   \   000151   7F0B         MOV     R7,#0xb
   \   000153   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   E4           CLR     A
   \   000006   93           MOVC    A,@A+DPTR
   \   000007   5403         ANL     A,#0x3
   \   000009   6401         XRL     A,#0x1
   \   00000B   22           RET
    444          
    445          
    446          
    447          
    448          /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
    449           *
    450           * If the returned value is 0, the device is not configured (not in the configured state)
    451           *
    452           * <b>Parameters</b>:
    453           * - VALUE: Always 0
    454           * - INDEX: Always 0
    455           * - LENGTH: Always 1
    456           *
    457           * <b>Data (IN)</b>:
    458           * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
    459           * configuration.
    460           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    461          void usbsrGetConfiguration(void)
   \                     usbsrGetConfiguration:
    462          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    463          
    464             // Sanity check
    465             if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
   \   000004   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_24:
   \   000007   7010         JNZ     ??usbsrGetConfiguration_0
   \   000009   A3           INC     DPTR
   \   00000A   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_19:
   \   00000D   700A         JNZ     ??usbsrGetConfiguration_0
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7002         JNZ     ??usbsrGetConfiguration_1
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??usbsrGetConfiguration_1:
   \   000017   6007         JZ      ??usbsrGetConfiguration_2
    466                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetConfiguration_0:
   \   000019   90....       MOV     DPTR,#usbfwData + 7
   \   00001C   7404         MOV     A,#0x4
   \   00001E   800C         SJMP    ??CrossCallReturnLabel_7
    467          
    468             // Return the current configuration
    469             } else {
    470                usbSetupData.pBuffer = &usbfwData.configurationValue;
   \                     ??usbsrGetConfiguration_2:
   \   000020   90....       MOV     DPTR,#usbSetupData
   \   000023   74..         MOV     A,#(usbfwData + 1) & 0xff
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   74..         MOV     A,#((usbfwData + 1) >> 8) & 0xff
   \   000029   12....       LCALL   ?Subroutine6
    471                usbSetupData.bytesLeft = 1;
    472                usbfwData.ep0Status = EP_TX;
    473             }
   \                     ??CrossCallReturnLabel_7:
   \   00002C   F0           MOVX    @DPTR,A
    474          
    475          } // usbsrGetConfiguration
   \   00002D   02....       LJMP    ?Subroutine1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   04           INC     A
   \   000006   12....       LCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_14:
   \   000009   22           RET
    476          
    477          
    478          
    479          
    480          /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
    481           *
    482           * The configuration value must either be 0, in which case the device enters the address state, or it
    483           * must match a configuration value from one of the USB configuration descriptors. If there is a match,
    484           * the device enters the configured state.
    485           *
    486           * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
    487           * function to automatically setup all endpoint registers.
    488           *
    489           * <b>Parameters</b>:
    490           * - VALUE: The configuration value (0-255)
    491           * - INDEX: Always 0
    492           * - LENGTH: Always 0
    493           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    494          void usbsrSetConfiguration(void)
   \                     usbsrSetConfiguration:
    495          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    496             uint8 n;
    497             USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
    498             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    499          
    500             // Sanity check
    501             if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6402         XRL     A,#0x2
   \   00000B   6014         JZ      ??usbsrSetConfiguration_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000010   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_20:
   \   000013   700C         JNZ     ??usbsrSetConfiguration_0
   \   000015   A3           INC     DPTR
   \   000016   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_21:
   \   000019   7006         JNZ     ??usbsrSetConfiguration_0
   \   00001B   90....       MOV     DPTR,#usbSetupHeader + 3
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6009         JZ      ??usbsrSetConfiguration_1
    502                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   F0           MOVX    @DPTR,A
   \   000027   02....       LJMP    ??usbsrSetConfiguration_2
    503          
    504             // Default endpoint setup
    505             } else {
    506                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
   \                     ??usbsrSetConfiguration_1:
   \   00002A                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7901         MOV     R1,#0x1
   \   00002E   12....       LCALL   usbsrHookProcessEvent
    507          
    508                // Configure relevant endpoints
    509                if (LO_UINT16(usbSetupHeader.value)) {
   \   000031   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6072         JZ      ??usbsrSetConfiguration_3
    510          
    511                   // Find the correct configuration descriptor...
    512                   pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
   \   000037                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000037   7A00         MOV     R2,#0x0
   \   000039   F9           MOV     R1,A
   \   00003A   12....       LCALL   usbdpGetConfigurationDesc
   \   00003D   8A..         MOV     ?V0 + 0,R2
   \   00003F   8B..         MOV     ?V0 + 1,R3
    513          
    514                   // If it exists...
    515                   if (pConfiguration) {
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V0 + 1
   \   000044   605B         JZ      ??usbsrSetConfiguration_4
    516                      usbfwData.usbState = DEV_CONFIGURED;
   \   000046   90....       MOV     DPTR,#usbfwData
   \   000049   7404         MOV     A,#0x4
   \   00004B   F0           MOVX    @DPTR,A
    517                      usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \   00004C   90....       MOV     DPTR,#usbSetupHeader + 2
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   90....       MOV     DPTR,#usbfwData + 1
   \   000053   F0           MOVX    @DPTR,A
    518          
    519                      // For each interface...
    520                      for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
   \   000054   75..00       MOV     ?V0 + 4,#0x0
   \                     ??usbsrSetConfiguration_5:
   \   000057   85..82       MOV     DPL,?V0 + 0
   \   00005A   85..83       MOV     DPH,?V0 + 1
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E4           CLR     A
   \   000062   93           MOVC    A,@A+DPTR
   \   000063   F8           MOV     R0,A
   \   000064   E5..         MOV     A,?V0 + 4
   \   000066   C3           CLR     C
   \   000067   98           SUBB    A,R0
   \   000068   504D         JNC     ??usbsrSetConfiguration_6
    521                         usbfwData.pAlternateSetting[n] = 0x00;
   \   00006A   85....       MOV     ?V0 + 2,?V0 + 4
   \   00006D   74..         MOV     A,#(usbfwData + 2) & 0xff
   \   00006F   25..         ADD     A,?V0 + 2
   \   000071   F8           MOV     R0,A
   \   000072   74..         MOV     A,#((usbfwData + 2) >> 8) & 0xff
   \   000074   3400         ADDC    A,#0x0
   \   000076   F9           MOV     R1,A
   \   000077   E8           MOV     A,R0
   \   000078   FE           MOV     R6,A
   \   000079   E9           MOV     A,R1
   \   00007A   FF           MOV     R7,A
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   E4           CLR     A
   \   000080   F0           MOVX    @DPTR,A
    522          
    523                         // Look only for alternate setting 0
    524                         do {
    525                            pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
   \                     ??usbsrSetConfiguration_7:
   \   000081                ; Setup parameters for call to function usbdpFindNext
   \   000081   7A00         MOV     R2,#0x0
   \   000083   7904         MOV     R1,#0x4
   \   000085   12....       LCALL   usbdpFindNext
    526                         } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
   \   000088   8A82         MOV     DPL,R2
   \   00008A   8B83         MOV     DPH,R3
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E4           CLR     A
   \   000090   93           MOVC    A,@A+DPTR
   \   000091   F8           MOV     R0,A
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   E0           MOVX    A,@DPTR
   \   000097   68           XRL     A,R0
   \   000098   70E7         JNZ     ??usbsrSetConfiguration_7
    527          
    528                         // Configure all endpoints in this interface
    529                         ConfigureEndpoints(pInterface);
   \   00009A                ; Setup parameters for call to function ConfigureEndpoints
   \   00009A   12....       LCALL   ConfigureEndpoints
    530                      }
   \   00009D   05..         INC     ?V0 + 4
   \   00009F   80B6         SJMP    ??usbsrSetConfiguration_5
    531          
    532                   // If not, then stall the endpoint
    533                   } else {
    534                      usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_4:
   \   0000A1   90....       MOV     DPTR,#usbfwData + 7
   \   0000A4   7404         MOV     A,#0x4
   \   0000A6   F0           MOVX    @DPTR,A
   \   0000A7   800E         SJMP    ??usbsrSetConfiguration_6
    535                   }
    536          
    537                // Unconfigure endpoints
    538                } else {
    539                   usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetConfiguration_3:
   \   0000A9   90....       MOV     DPTR,#usbfwData + 1
   \   0000AC   F0           MOVX    @DPTR,A
    540                   usbfwData.usbState = DEV_ADDRESS;
   \   0000AD   90....       MOV     DPTR,#usbfwData
   \   0000B0   7403         MOV     A,#0x3
   \   0000B2   F0           MOVX    @DPTR,A
    541                   usbfwSetAllEpStatus(EP_HALT);
   \   0000B3                ; Setup parameters for call to function usbfwSetAllEpStatus
   \   0000B3   F9           MOV     R1,A
   \   0000B4   12....       LCALL   usbfwSetAllEpStatus
    542                }
    543                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
   \                     ??usbsrSetConfiguration_6:
   \   0000B7                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000B7   7A00         MOV     R2,#0x0
   \   0000B9   7902         MOV     R1,#0x2
   \   0000BB   12....       LCALL   usbsrHookProcessEvent
    544             }
    545          
    546          } // usbsrSetConfiguration
   \                     ??usbsrSetConfiguration_2:
   \   0000BE   7F05         MOV     R7,#0x5
   \   0000C0   02....       LJMP    ?FUNC_LEAVE_XDATA
    547          
    548          
    549          
    550          
    551          /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
    552           * specified interface)
    553           *
    554           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    555           * the host to determine the currently selected alternate setting.
    556           *
    557           * <b>Parameters</b>:
    558           * - VALUE: Always 0
    559           * - INDEX: Interface number
    560           * - LENGTH: Always 1
    561           *
    562           * <b>Data (IN)</b>:
    563           * The alternate setting for the selected interface
    564           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    565          void usbsrGetInterface(void)
   \                     usbsrGetInterface:
    566          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    567          
    568             // Sanity check
    569             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7019         JNZ     ??usbsrGetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6481         XRL     A,#0x81
   \   000013   7011         JNZ     ??usbsrGetInterface_0
   \   000015   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_25:
   \   000018   700C         JNZ     ??usbsrGetInterface_0
   \   00001A   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6401         XRL     A,#0x1
   \   000020   7002         JNZ     ??usbsrGetInterface_1
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \                     ??usbsrGetInterface_1:
   \   000024   6007         JZ      ??usbsrGetInterface_2
    570                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetInterface_0:
   \   000026   90....       MOV     DPTR,#usbfwData + 7
   \   000029   7404         MOV     A,#0x4
   \   00002B   801A         SJMP    ??CrossCallReturnLabel_8
    571          
    572             // Return the current alternate setting
    573             } else {
    574                usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
   \                     ??usbsrGetInterface_2:
   \   00002D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000030   E0           MOVX    A,@DPTR
   \   000031   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   000033   F5..         MOV     ?V0 + 0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   000039   F5..         MOV     ?V0 + 1,A
   \   00003B   90....       MOV     DPTR,#usbSetupData
   \   00003E   E5..         MOV     A,?V0 + 0
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E5..         MOV     A,?V0 + 1
   \   000044   12....       LCALL   ?Subroutine6
    575                usbSetupData.bytesLeft = 1;
    576                usbfwData.ep0Status = EP_TX;
    577             }
   \                     ??CrossCallReturnLabel_8:
   \   000047   F0           MOVX    @DPTR,A
    578          
    579          } // usbsrGetInterface
   \   000048   7F03         MOV     R7,#0x3
   \   00004A   02....       LJMP    ?FUNC_LEAVE_XDATA
    580          
    581          
    582          
    583          
    584          /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
    585           * interface)
    586           *
    587           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    588           * the host to select the desired alternate setting.
    589           *
    590           * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
    591           * registers.
    592           *
    593           * <b>Parameters</b>:
    594           * - VALUE: Alternate setting
    595           * - INDEX: Interface number
    596           * - LENGTH: Always 0
    597           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    598          void usbsrSetInterface(void)
   \                     usbsrSetInterface:
    599          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    600             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    601          
    602             // Sanity check
    603             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7010         JNZ     ??usbsrSetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7008         JNZ     ??usbsrSetInterface_0
   \   000015   90....       MOV     DPTR,#usbSetupHeader + 6
   \   000018   12....       LCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_22:
   \   00001B   6008         JZ      ??usbsrSetInterface_1
    604                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetInterface_0:
   \   00001D   90....       MOV     DPTR,#usbfwData + 7
   \   000020   7404         MOV     A,#0x4
   \   000022   F0           MOVX    @DPTR,A
   \   000023   8052         SJMP    ??usbsrSetInterface_2
    605          
    606             // Verify that the desired alternate setting is available, and then make the switch
    607             } else {
    608                if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
   \                     ??usbsrSetInterface_1:
   \   000025                ; Setup parameters for call to function usbdpGetInterfaceDesc
   \   000025   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FB           MOV     R3,A
   \   00002A   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FA           MOV     R2,A
   \   00002F   90....       MOV     DPTR,#usbfwData + 1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F9           MOV     R1,A
   \   000034   12....       LCALL   usbdpGetInterfaceDesc
   \   000037   8A..         MOV     ?V0 + 0,R2
   \   000039   8B..         MOV     ?V0 + 1,R3
   \   00003B   AE..         MOV     R6,?V0 + 0
   \   00003D   AF..         MOV     R7,?V0 + 1
   \   00003F   EE           MOV     A,R6
   \   000040   4F           ORL     A,R7
   \   000041   60DA         JZ      ??usbsrSetInterface_0
    609                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
   \   000043                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000043   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FA           MOV     R2,A
   \   000048   7903         MOV     R1,#0x3
   \   00004A   12....       LCALL   usbsrHookProcessEvent
    610                   usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
   \   00004D   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000050   E0           MOVX    A,@DPTR
   \   000051   C0E0         PUSH    A
   \   000053   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000056   E0           MOVX    A,@DPTR
   \   000057   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   000059   F8           MOV     R0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   00005E   F9           MOV     R1,A
   \   00005F   8882         MOV     DPL,R0
   \   000061   8983         MOV     DPH,R1
   \   000063   D0E0         POP     A
   \   000065   F0           MOVX    @DPTR,A
    611          
    612                   // Configure all endpoints in this interface
    613                   ConfigureEndpoints(pInterface);
   \   000066                ; Setup parameters for call to function ConfigureEndpoints
   \   000066   EE           MOV     A,R6
   \   000067   FA           MOV     R2,A
   \   000068   EF           MOV     A,R7
   \   000069   FB           MOV     R3,A
   \   00006A   12....       LCALL   ConfigureEndpoints
    614                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
   \   00006D                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00006D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FA           MOV     R2,A
   \   000072   7904         MOV     R1,#0x4
   \   000074   12....       LCALL   usbsrHookProcessEvent
    615          
    616                // This interface does not exist
    617                } else {
    618                   usbfwData.ep0Status = EP_STALL;
    619                }
    620             }
    621          
    622          } // usbsrSetInterface
   \                     ??usbsrSetInterface_2:
   \   000077   02....       LJMP    ?Subroutine0
    623          
    624          //@}
    625          
    626          /*
    627          +------------------------------------------------------------------------------
    628          |  Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
    629          |
    630          |  IMPORTANT: Your use of this Software is limited to those specific rights
    631          |  granted under the terms of a software license agreement between the user who
    632          |  downloaded the software, his/her employer (which must be your employer) and
    633          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    634          |  unless you agree to abide by the terms of the License. The License limits
    635          |  your use, and you acknowledge, that the Software may not be modified, copied
    636          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    637          |  solely and exclusively in conjunction with a Texas Instruments radio
    638          |  frequency transceiver, which is integrated into your product. Other than for
    639          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    640          |  works of, modify, distribute, perform, display or sell this Software and/or
    641          |  its documentation for any purpose.
    642          |
    643          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    644          |  PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    645          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    646          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    647          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    648          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    649          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    650          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    651          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    652          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    653          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    654          |
    655          |  Should you have any questions regarding your right to use this Software,
    656          |  contact Texas Instruments Incorporated at www.TI.com.
    657          |
    658          +------------------------------------------------------------------------------
    659          */

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     ChangeFeature                      1      0      9
       -> usbsrHookProcessEvent         0      0     18
       -> usbsrHookProcessEvent         0      0     18
       -> usbsrHookProcessEvent         0      0     18
     ConfigureEndpoints                 0      0     30
       -> usbdpFindNext                 0      0     36
     usbsrClearFeature                  0      0      0
       -> ChangeFeature                 0      0      0
       -> usbsrHookClearFeature         0      0      0
     usbsrGetConfiguration              2      0      0
     usbsrGetDescriptor                 1      0     13
       -> usbdpGetDeviceDesc            0      0     26
       -> usbdpGetConfigurationDesc     0      0     26
       -> usbdpGetStringDesc            0      0     26
     usbsrGetInterface                  0      0     10
     usbsrGetStatus                     0      0      9
     usbsrSetAddress                    2      0      0
     usbsrSetConfiguration              0      0     12
       -> usbsrHookProcessEvent         0      0     24
       -> usbdpGetConfigurationDesc     0      0     24
       -> usbdpFindNext                 0      0     24
       -> ConfigureEndpoints            0      0     24
       -> usbfwSetAllEpStatus           0      0     24
       -> usbsrHookProcessEvent         0      0     24
     usbsrSetFeature                    0      0      0
       -> ChangeFeature                 0      0      0
       -> usbsrHookSetFeature           0      0      0
     usbsrSetInterface                  1      0      9
       -> usbdpGetInterfaceDesc         0      0     18
       -> usbsrHookProcessEvent         0      0     18
       -> ConfigureEndpoints            0      0     18
       -> usbsrHookProcessEvent         0      0     18


   Segment part sizes:

     Function/Label        Bytes
     --------------        -----
     usbsrGetStatus         212
     ?Subroutine0             5
     ?Subroutine2             3
     ??Subroutine10_0         8
     ?Subroutine9             9
     status                   2
     ChangeFeature          235
     usbsrClearFeature       12
     usbsrSetFeature         12
     usbsrSetAddress         67
     ?Subroutine1             5
     ?Subroutine3             7
     usbsrGetDescriptor     374
     ?Subroutine5            15
     ?Subroutine8            10
     ?Subroutine4            10
     ConfigureEndpoints     342
     ?Subroutine7            12
     usbsrGetConfiguration   48
     ?Subroutine6            10
     usbsrSetConfiguration  195
     usbsrGetInterface       77
     usbsrSetInterface      122

 
 1 790 bytes in segment NEAR_CODE
     2 bytes in segment XDATA_Z
 
 1 790 bytes of CODE  memory
     2 bytes of XDATA memory

Errors: none
Warnings: none
